# Компьютерные сети

**Лектор**: Сергей Вячеславович Мельников

## Лекция 1. Обзорная

**Система оценивания**:
1. Будут лабораторные работы;
2. Для получения оценки B и ниже можно будет написать тест;
3. Для получения оценки A нужно сходить на устный экзамен (примерно 15 минут диалога с преподавателем).

**Рекомендуемая литература**:
1. Computer Networking: A Top Down Approach (8th edition, Jim Kurose, Keith Ross);
2. Computer Networks (Andrew Tanenbaum, David Wetherall).

### Про что вообще наш курс?

Самый простой способ передавать данные между двумя компьютерами - просто соединить их проводом. Однако данный подход очень сложно и неэффективно масштабируется, поэтому мы будем рассматривать методы построения сетей между многими компьютерами, пытаясь при этом экономить ресурсы. Первый более интеллектуальный способ построить сеть между более чем двумя компьютерами - это **circuit switcing** (рус. *коммутация каналов*).

### Circuit switching

**Сеть с коммутацией каналов** - это вид телекоммуникационной сети, в которой между двумя узлами должно быть установлено соединение (канал), прежде чем они начнут обмен информацией. Данное соединение на протяжении всего сеанса обмена информацией может использоваться только указанными двумя узлами. После завершения обмена соединение должно быть соответствующим образом разорвано. Фактически в системе находятся переключатели, которые соединяют нужные компьютеры между собой.

![circuit switching](./images/circuit-switching-networks.png "Circuit Switching")

Данный вид связи имеет ряд преимуществ:
1. Высокую стабильность параметров каналов во времени (например, пропускной способности);
2. Отсутствие необходимости в передаче служебной информации после установления соединения;
3. Коммутация каналов может использоваться как в аналоговых, так и в цифровых сетях связи (в отличие от packet switching, который будет рассмотрен ниже).

Основной недостаток данного способа заключается в малой его эффективности: канальная емкость расходуется на поддержание соединений, которые установлены, но (в настоящее время) не используются.

**Пример**: Сообщения в любимом мессенджере могут оправляться раз в минуту, но пользователи будут занимать канал связи всё время.

**Примечание**: Данный тип связи раньше использовался для телефонной связи, поэтому междугородняя связь была очень дорогой.

### Packet Switching

**Коммутация пакетов** (англ. *packet switching*) - это способ динамического распределения ресурсов сети связи за счет передачи и коммутации оцифрованной информации в виде частей небольшого размера - так называемых *пакетов*, которые передаются по сети в общем случае независимо друг от друга (*датаграммы*), либо последовательно друг за другом по виртуальным соединениям. Узел-приемник из пакетов собирает сообщение.

Фактически packet switching - это circuit switching, с делением информации на пакеты. При использовании данного способа не требуется занимать канал связи всю отправку сообщения. Поэтому в таких сетях по одной физической линии связи могут обмениваться данными много узлов.

**Недостатки** (*только маленькая часть из них*):
1. Пакеты могут заблудиться, не дойти, прийти два раза и т.д.
2. Кто-то "посередине" может не захотеть передавать пакеты.

Несмотря на эти недостатки, сейчас практически все сети работают именно так.

### Интернет

**Интернет** - это "очень много устройств, которые хотят общаться друг с другом". Он состоит из:
1. Миллиардов устройств - *хостов*;
2. Packet Switches: routers, switches;
3. Communication links: fiber, copper, radio, satellite, transmission rate: bandwidth;
4. Networks - групп устройств, роутеров, каналов, управляемых одной организацией.

### Пакеты

Каждый пакет имеет размер. Пусть это L бит. Каналы имеют **пропускную способность** R (англ. *transmission rate*, *capacity*, *bandwidth*) - то, с какой скоростью мы можем передавать данные. Таким образом, передачи пакета по такому каналу (packet transmission delay) равно L (bits) / R (bits/sec) (ниже поговорим о том, почему эта формула не совсем правильная). Рассмотрим, как мы можем физически передавать пакеты:
1. Витая пара (англ. *twisted pair*, *TP*) - вид кабеля связи, который представляет собой одну или несколько пар изолированных проводников, скрученных между собой, покрытых пластиковой оболочкой. Пропускная способность категории 5 равна 100 Mbps, 1 Gbps Ethernet. Категории 6 - 10 Gbps Ethernet.
2. Коаксиальный кабель (англ. *coaxial cable*) - электрический кабель, состоящий из центрального проводника и экрана, расположенных соосно и разделенных изоляционным материалом или воздушным промежутком. 100's Mbps / канал.
3. Оптическое волокно (англ. *fiber optic cable*) - нить из оптически прозрачного материала (стекло, пластик), используемая для переноса света внутри себя посредством полного внутреннего отражения. 10's - 100's Gbps.
4. Радио. Имеет ряд недостатков, зато является беспроводным каналом. Типы радио:
   1. Wireless LAN (WiFi) - 10-100's Mbps, 10's meters;
   2. wide-area (например, 4G cellular) - 10's Mbps / ~10 км;
   3. Bluetooth - очень быстрый, но работает только на коротких расстояниях;
   4. terrestrial microwave - 45 Mbps;
   5. satellite - до 45 Mbps.

![Submarine cable map](./images/submarine-cable-map.jpg "Карта оптических волокон, протянутых между материками")

При пересылке пакетов есть две разные функции - **форвардинг** (англ. *forwarding* или *switching*) и **роутинг** (англ. *routing*).

**Форвардинг** (англ. *forwarding* или *switching*) - это *локальная задача* передачи полученного пакета данных с ввода роутера на подходящий выход роутера.

**Роутинг** (англ. *routing*) - это *глобальная задача* определения путей от отправителя к получателю для пакетов данных.

**Пример**: Если вы едете из одного города в другой, то роутинг - это задача построения маршрута, а форвардинг - это задача в рамках конкретного города на вашем пути, которая заключается в решении вопроса, куда необходимо повернуть.

Чтобы выполнить форвардинг, нужно получить пакет целиком, поэтому на самом деле скорость передачи пакета по сети не равна L / R, требуется еще прибавить некоторый delay - задержку, которая возникает в узлах на получение пакета целиком.

**Пример**: Если передавать пакет размера 10 MB по оптическому волокну длины 100 ms с пропускной способностью 10 Mbps, то суммарное кол-во времени будет равно 10 MB / 10 Mbps + 100 ms = 8.1 s. Однако, если посередине будет еще один узел, то сначала потребуется 10 MB / 10 Mbps + 50 ms, а затем еще столько же. Итоговое время будет равно 16.1 s (узел посередине должен получить пакет целиком).

![Packets transmission delay example](./images/packets-transmission-delay-example.jpg "Пример возникновения задержки из-за промежуточного узла")

**Примечание**: Обычно пакеты имеют размер порядка килобайтов, поэтому в примере выше при делении всех данных на маленькие пакеты узел посередине смог бы начать передавать данные, получив первый пакет, а это произошло бы почти мгновенно.

Узлы имеют очереди пакетов, так как обрабатывать прибывающие пакеты можно только линейно. Очередь имеет фиксированный размер, обычно не очень большой и потери пакетов происходят как раз потому что пакеты не помещаются в очереди. Одна из задач протокола передачи данных - обрабатывать такую ситуацию. Например, сообщать отправителю, что его пакет потерялся.

**Протокол передачи данных** - это набор соглашений интерфейса логического уровня, которые определяют обмен данными между различными программами. Эти соглашения задают единообразный способ передачи сообщений и обработки ошибок при взаимодействии программного обеспечения разнесенной в пространстве аппаратуры, соединенной тем или иным интерфейсом.

**Сетевой протокол** - это набор правил и действий (очередностей действий), позволяющий осуществлять соединение и обмен данными между двумя или более включенными в сеть устройствами.

*Стандарты Интернета*:
1. RFC (Request for Comments) - документ, в котором описано, как работает стандарт (например, RFC 6797);
2. IETF (Internet Engineering Task Force) - организация, которая принимает RFC, и публикует их (тогда у RFC появляется номер);
3. ISO (International Organization for Standardization) - организация, которая стандартизирует "всё подряд" (не только Интернет и что-то связанное с компьютерами). Недостатком является то, что все ее стандарты платные.

**Примечание**: Обычно стандарты (протоколы) стараются максимально экономить биты:

![Protocols examples](./images/protocols-examples.png "Примеры протоколов")

Уровни абстракции интернет протоколов:
1. Application - поддержка сетевых приложений (HTTP, IMAP, SMTP, DNS)
2. Transport - передача данных (TCP, UDP)
3. Network - роутинг датаграмм от отправителя к получателю (IP, routing protocols)
4. Link - передача данных между соседними элементами сети (Ethernet, 802.11 - WiFi, PPP)
5. Physical - биты в проводах

![Real Internet Stack](./images/real-internet-stack.png "Real Internet Stack")

**ISO/OSI model** (*The Open Systems Interconnection model*, рус. *ЭМВОС* - *эталонная модель взаимодействия открытых систем*) - сетевая модель стека сетевых протоколов, состоящая из следующих уровней:
- L7: application (прикладной) - доступ к сетевым службам: HTTP, FTP, POP3, SMTP, WebSocket;
- L6: presentation (уровень представления) - представление и шифрование данных: ASCII, EBCDIC, SSL, gzip;
- L5: session (сеансовый) - управление сеансом связи: RPC, PAP, L2TP, gRPC;
- L4: transport (транспортный) - прямая связь между конечными пунктами и надежность: TCP, UDP, SCTP, порты;
- L3: network (сетевой) - определение маршрута и логическая адресация: IPv4, IPv6, IPsec, AppleTalk, ICMP;
- L2: link (канальный) - физическая адресация: PPP, IEEE, 802.22, Ethernet, DSL, ARP, сетевая карта;
- L1: physical (физический) - работа со средой и передачи, сигналами и двоичными данными: USB, RJ ("витая пара", коаксиальный, оптоволоконный), радиоканал.

## Лекция 2. Протокол IP

**IP** (англ. *Internet Protocol*, досл. *межсетевой протокол*) - маршрутизируемый протокол сетевого уровня стека TCP/IP.

### Адресация

Первая задача, решаемая протоколом IP - это адресация. Существует два вида IP-адресов:
1. IPv4 (RFC791)
  - 32 бита;
  - `87.250.250.242` - 32 бита разбиты на 4 байта, каждый из которых записан десятичным числом;
2. IPv6 (RFC1883)
  - 128 битов;
  - `2a02:06b8:0000:0000:0000:0000:0002:0242` - 128 бит разбиты на 8 групп по 2 байта, каждая из которых записывается в шестнадцатеричной системе счисления;
  - `2a02:6b8::2::242` (можно не писать ведущие нули и выкинуть *одну* последовательность нулевых групп);
  - `::ffff:87.250.250.242` - IPv4 адрес можно записать как IPv6 адрес; можно переписать как `::ffff:57fa:faf2`.

**Примечание**: На самом деле это только основные способы записывать IP-адреса. Например, десятичное число - это тоже корректный IP-адрес.

**Маска подсети** - битовая маска для определения по IP-адреса адреса подсети или адреса узла (хоста, компьютера, устройства) этой подсети. Представляет собой 32-битное число, у которого вначале идут единицы, а затем нули. Может записываться числом после IP-адреса, равным число единиц в маске.

**Пример**: `87.250.250.0/23`

![ipcalc example](images/ipcalc-example.png "ipcalc")

**Примечание**: В маске `/31` можно использовать все адреса (их всего два), маска `/32` указывает на то, что это конкретный IP-адрес.

Наиболее частое место, где встречаются маски сети - это **таблицы маршрутизации** (англ. *forwarding tables*) - электронные таблицы (файлы) или базы данных, хранящиеся на маршрутизаторе или сетевом компьютере и описывающие соответствие между адресами назначения и интерфейсами, через которые следует отправить пакет данных до следующего маршрутизатора (являются простейшей формой правил маршрутизации). Обычно содержат:
- *Адрес* сети или узла назначения, либо указание, что маршрут является маршрутом по умолчанию;
- *Маску сети назначения* (правила с *наибольшей длиной маски* более приоритетны);
- *Шлюз*, обозначающий адрес маршрутизатора в сети, на который необходимо отправить пакет, следующий до указанного адреса назначения;
- *Интерфейс*, через который доступен шлюз;
- *Метрику* - числовой показатель, задающий предпочтительность маршрута (маршруты с меньшим числом более предпочтительны).

**Примеры**:
1. `10.0.0.0/8 via 192.168.1.1`
2. `10.1.0.0/16 via 192.168.1.2`
3. `10.1.2.0/24 via 192.168.1.3`
4. `192.168.99.0/24 dev wlan0`
5. `0.0.0.0/0 via 192.168.99.1`
В данном случае для адреса `10.1.1.0` подходят первые два правила, но будет выбрано второе, так как длина маски сети во втором правиле больше. Запись с `dev` означает, что интерфейс находится в локальной сети. `via` указывает на устройство, которое разберется, куда отправить пакет. Правило с маской `/0` также обозначаемое как `default` является правилом по умолчанию, подходящим под любой адрес.

**Примечание**: Строить таблицы маршрутизации можно *вручную* (`sudo ip r add 172.16.0.0/24 via 192.168.93.7`).

### Как получить IP-адрес?

В 1997 или в 2007, имея хорошие soft-скилы можно было обратиться к **провайдеру** (англ. *ISP*, *Internet Service Provider*) и попросить у него IP-адреса. Провайдер получает их от **региональных интернет-регистраторов** (англ. *RIR*, *Regional Internet Registry*). Организация **IANA** (*Internet Assigned Numbers Authority*) - глобальная организация, выдающая IP-адреса региональным интернет-регистраторам. Данный процесс на сегодняшний день актуален только для IPv6.

На сегодняшний день произошло такое явление как **IPv4 address exhaustion** (рус. *исчерпание адресов IPv4*):

![RIR IPv4 Address Run-Down Model](./images/rir-ipv4-exhaustion-projection.png "Исчерпание адресов IPv4")

Можно видеть, что сейчас IPv4 адресов у RIR'ов не осталось, поэтому можно прийти к каким-то компаниям, которые имеют, например, `/8` IP-адреса, купить у них `/24` IP-адреса и пользоваться. Тогда по всему миру в таблицах маршрутизации будет объявлено, что теперь у этих адресов новый владелец. Для любого IP-адреса можно посмотреть, кто его владелец, используя, например, команду `whois` в Linux.

IPv6 адреса раздают только из подсети `2000::/3` (то есть только 1/8 всех адресов, чтобы если что-то пойдет не так, то было еще 7 попыток раздавать адреса) и минимальный их размер - `/48`.

### Специальные IP-адреса

**Loopback** - адреса `127.0.0.1/8` и `::1/128`. Если отправлять пакета по этим адресам, то они вернутся.

`::/128`, `0.0.0.0/8` - адреса, означающие отсутствие адреса или любые адреса (интерпретация зависит от контекста).

**Приватные IP-адреса** - их можно использовать в локальных сетях без согласования с IANA:
- `192.168.0.0/16`
- `172.16.0.0/12`
- `10.0.0.0/8`
- `100.64.0.0/10`
- `fd00::/8`

## Network address translation

**NAT** (*Network Address Translation*, *IP Masquerading*, *Network Masquerading*, *Native Address Translation*) - это механизм в сетях TPC/IP, позволяющий преобразовывать IP-адреса транзитных пакетов. Наиболее популярным является **SNAT**, суть механизма которого состоит в замене адреса источника (англ. *source*) при прохождении пакета в одну сторону и обратной замене адреса назначения (англ. *destination*) в ответном пакете. При использовании TCP и UDP при обратном преобразовании для получения роутером исходного адреса, который отправлял пакет, используются порты.

![NAT Concept](./images/nat-concept.png "NAT Concept")

**Примечание**: Обычно по пути в интернет происходит несколько NAT. Можно посмотреть свой "путь" до интернета, используя Linux утилиту `mtr` (My traceroute).

**Примечание**: NAT для IPv6 *бесполезен*.

**Link local IP-адреса** - адреса сети, которые предназначены только для коммуникаций в пределах одного сегмента местной сети или магистральной линии, используются для автоматического конфигурирования сетевого адреса, в случаях, когда внешние источники информации об адресах сети недоступны:
- `169.254.0.0/16`
- `fe80::/10`

**Broadcast**:
- `87.250.250.0/23`;
  - `87.250.251.255` - directed broadcast;
- `255.255.255.255/32` - local network broadcast;

**Multicast**:
- `224.0.0.0/4`
  - `244.0.0.1` - All Systems on this Subnet
- `ff00::/8`
  - `ff01:0:0:0:0:0:0:1` - All Nodes (Node-Local)
  - `ff01:0:0:0:0:0:0:2` - All Routers Address (Node-Local)
  - `ff02:0:0:0:0:0:0:1` - All Nodes Address (Link-Local)
  - `ff02:0:0:0:0:0:0:2` - All Routers Address (Link-Local)
  - `ff05:0:0:0:0:0:0:2` - All Routers Address (Site-Local)

### Мета-информация

![IP packets](./images/ip-packets.png "IP packets structure")

#### Фрагментация (fragmentation)

Иногда большой пакет не может пройти через линк, поэтому его можно разделить на фрагменты.

IPv4 flags:
- `DF` - нет фрагментов
- `MF` - еще есть фрагменты

IPv6:
- Фрагментации нет
- Есть гарантия, что 1280 пройдут по IPv6 линку

Получатель, когда получает фрагментированный IP пакет, должен выделить буфер и ждать. Ждать можно до бесконечности, фрагментов может приходить потенциально сколько угодно, поэтому фрагментация - это серьезная опасность для получателя. В частности поэтому от нее отказались в IPv6.

**MTU** (*maximum transmission unit*) - максимальный размер полезного блока данных одного пакета, который может быть передан протоколом без фрагментации.

**Path MTU discovery** - процесс поиска MTU (например, бин. поиском).

#### TTL

**TTL** - time to live для IPv4 и hop limit для IPv6. Число, которое уменьшается при прохождении узла, чтобы IP-пакеты не "гуляли" по Интернету бесконечно. Ограничено 1 байтом, но этого достаточно, так как диаметр Интернета сейчас примерно 70.

**Примечание**: Обычно хосты отправляют информацию о том, что они выкинули пакет по TTL - *time exceeded*, поэтому можно собрать утилиту `mtr`, отправляя IP-пакеты с TTL 1, 2 и т. д.

**Примечание**: Утилита `wireshark` позволяет посмотреть, какие пакеты мы шлем.

## Лекция 3. ICMP. NAT64. Работа IP поверх Ethernet и WiFi

### ICMP

**ICMP** (англ. *Internet Control Message Protocol* - *протокол межсетевых управляющих сообщений*) - сетевой протокол, входящий в стек протоколов TCP/IP и работающий поверх IP. В основном используется для передачи сообщений об ошибках и других исключительных ситуациях, возникших при передаче данных, например, запрашиваемая услуга недоступна или хост или маршрутизатор не отвечают. Также на него возложены некоторые сервисные функции.

**Включает в себя**:
- Echo request
- Echo reply
- Destination Unreachable:
  - Fragmentation required
  - Destination host unreachable
  - Destination network unreachable
  - Destination port unreachable
  - * administratively prohibited
- Time exceeded
- ~~Traceroute~~

### NAT64

**NAT64** - метод преобразования IPv6 адреса, позволяющий связь между узлами IPv6 и IPv4 с помощью NAT. К адресу добавляется префикс `64:ff9b::/96`.

### Работа IP поверх Ethernet и WiFi

У любого устройства, подключенного к Ethernet или WiFi, должен быть адрес - MAC-адрес.

**MAC-адрес** - уникальный идентификатор, присваиваемый каждой единице сетевого оборудования или некоторым их интерфейсам в компьютерных сетях Ethernet. Состоит из шести байтов (записываются через двоеточие):
- `48:8f:5a:96:58:97`
- Broadcast: `ff:ff:ff:ff:ff:ff`

**Примечание**: MAC-адреса должны быть уникальными в рамках сети.

![MAC-48 Address](./images/mac-48-address.png "MAC-48 address")

Глобальные MAC-адреса устанавливаются производителями. По-хорошему им необходимо получать префикс из трех байтов для MAC-адресов в специальной организации за большую цену. Однако, де-факто, производители, например, умных лампочек могут использовать эти адреса циклически (никто им не запретит).

Иногда хочется назначить устройству MAC-адрес самостоятельно. Например, для сетевой карточки виртуальной машины или когда не хочется выдавать свой реальный MAC-адрес (Android это делает при подключении к незнакомой сети). Предпоследний бит MAC-адреса позволяет установить флаг, указывающий, что он администрируется самостоятельно.

**Ethernet frame** (идеологически то же, что и пакет) - блок данных протокола канального уровня.

![Ethernet frame](./images/ethernet-frame.png "Ethernet Frame structure")

Изначально компьютеры по коаксиальному кабелю соединялись друг с другом и если кто-то кому-то что-то отправлял - получали все. Сейчас есть другие подходы к объединению компьютеров в локальную сеть:
1. **Хаб** (англ. *hub*) - L1 (physical) - дублирует полученный сигнал всем (эмулирует описанную выше систему). Скорость передачи ограничена 10 Мб (кажется, что ничего не мешает делать их быстрее, но по стандарту нельзя).
2. **Коммутатор**, **свитч** (англ. *shitch*) - L2 (link) - запоминает MAC-адреса тех, кто шлет пакеты через него (считает их актуальными до истечения некоторого TL). Пересылает пакеты только тем, кому действительно предназначался пакет. При этом коммутаторы обычно понимают, что к одному порту могут быть подключены несколько устройств с разными MAC-адресами.
   - *L2 коммутаторы не умеют хорошо обрабатывать циклы*. Ethernet фрэймы не содержат никакого TTL - эти данные есть только на уровне IP, поэтому пакеты в сети, в которой есть *кольцо*, могут передаваться по кругу бесконечно. Современные коммутаторы имеют простенькую защиту от циклов *на крайний случай*: как только он видит на двух портах одинаковые MAC-адресы, он выключает один из этих двух портов.
3. **Маршрутизатор** (англ. *router*) - L3 (network) - принимает фрэймы, распаковывает их и решает кому послать, основываясь на IP-адресе получателя, а не на его MAC-адресе. Подразумевается, что к маршрутизатору подключены независимые сегменты сети Ethernet. Устройство, подключенное к роутеру знает только свой MAC-адрес и MAC-адрес роутера, остальные ему не нужны. В остальном маршрутизаторы работают также как коммутаторы (просто на другом уровне абстракции).

**Примечание**: Казалось бы - можно не использовать свичи, так как роутеры удобнее и стильнее, но они к тому же значительно дороже, так как содержат более умную логику. В целом различие между свичами и роутеры достаточно размыто.

**Замечание**: Чтобы отправлять кому-то IP пакеты через коммутаторы, нужно знать MAC-адрес получателя. Например, если у нас есть IP-адрес получателя - `192.168.93.2`, то нам нужно узнать его MAC-адрес для формирования Ethernet фрэйма. Хороший план - послать всем (`ff:ff:ff:ff:ff:ff`) сообщение "Who has `192.168.93.2`? Tell `192.168.93.90`" и дождаться от кого-то ответа ("`192.168.93.2` is at `b8:27:eb:e4:de:61`"). Стандартизирован этот процесс протоколом ARP.

**ARP** (*address resolution protocol*, RFC826) - протокол в компьютерных сетях, предназначенный для определения MAC-адреса другого компьютера по известному IP-адресу. Актуален в рамках одного Ethernet-сегмента. В Linux можно открыть ARP таблицу командой `arp -n`/`arp -a`.

**ND** (*neighbor discovery protocol*) - аналог ARP для IPv6.

## Лекция 4. DHCP. DHCPv6. UDP и TCP

### DHCP

**DHCP** (*Dynamic Host Configuration Protocol* - *протокол динамической настройки узла*) - сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. Работает по модели "клиент-сервер". Для автоматической конфигурации компьютер-клиент на этапе конфигурации сетевого устройства обращается к так называемому серверу DHCP и получает от него нужные параметры. Сетевой администратор может задать диапазон адресов, распределяемых сервером среди компьютеров. Это позволяет измежать ручной настройки компьютеров сети и уменьшает количество ошибок.

DHCP работает поверх UDP, поэтому чтобы получить IP-адрес по DHCP, нам нужно отправить IP пакет:
1. Отправляется `DHCPDISCOVER` с source IP `0.0.0.0` (обозначает отсутствие IP-адреса) и MAC `11:22:33:aa:bb:cc` (реальный MAC) на DHCP сервер. Поскольку мы не знаем ни его IP-адрес, ни его MAC-адрес, отправляем на broadcast: `255.255.255.255`, `ff:ff:ff:ff:ff:ff`.
2. DHCP сервер отправляет `DHCPOFFER` на IP `1.2.3.4` (предлагаемый адрес) и MAC `11:22:33:aa:bb:cc` со своих IP и MAC-адресов: `1.1.1.1`  `ab:cd:ef:12:34:56`.
3. В качестве ответа отправляется `DHCPREQUEST` или `DHCPRELEASE` чтобы согласиться на предложенный IP-адрес или отказаться от него соответственно (они всё еще отправляются с IP-адреса `0.0.0.0`).
4. DHCP отправляет в ответ `DHCPACK` в качестве подтверждения присвоения IP-адреса, либо `DHCPNAK`, если он не может выдать этот адрес и надо начинать весь процесс сначала.

**Примечание**: Поскольку обычно никто не освобождает IP-адреса, когда они не нужны, DHPC сервер выдает их на время (в публичных сетях обычно небольшое).

**Диаграмма состояний DHCP-клиента**:

![DHCP State Diagram](./images/dhcp-client-state-diagram.png "DHCP State Diagram")

Вторая функция DHCP - это **сетевая загрузка** - технология, когда вместе с IP-адресом выдается ссылка на сервер, с которого можно скачать операционную систему на лету (без использования жесткого диска).

### UDP

**UDP** (*User Datagram Protocol*) - один из ключевых элементов набора сетевых протоколов для Интернета. С UDP компьютерные приложения могут посылать сообщения другим хостам по IP-сети без необходимости предварительного сообщения для установки специальных каналов передачи или путей данных.

**Дейтаграмма** (англ. *Datagram*) - блок информации, передаваемый протоколом через сеть связи без предварительного установления соединения и создания виртуального канала.

![UDP Datagram](./images/udp-datagram.svg "UDP Datagram")

**Примечание**: `Segment lenght` указывается в байтах и включает в себя заголовок UDP дейтаграммы.

**Примечание**: В Linux и MacOS можно использовать утилиту `netcat` (сокращенно - `nc`), чтобы работать с UDP (`-u`). Например, можно слушать (`-l`) все пакеты, которые приходят на порт (`-p`) 1234, с помощью команды `nc -u -l -p 1234`. Аналогично можно отправлять UDP-пакеты: `nc -u 127.0.0.1 1234`. Если выполнять эти команды в соседних терминалах, то в первом будут видны сообщения, отправленные из второго.

### TFTP

- Протокол, который позволяет отправлять больше информации, чем помещается в UDP datagram.

**TFTP** (*Trivial File Transfer Protocol* - *простой протокол передачи файлов*) - ~~RFC768~~ RFC 1350 - протокол, основанный на транспортном протоколе UDP и работающий по следующему алгоритму:
1. Мы последовательно отправляем пронумерованные UDP datagram'ы и ждем на неё ACK - ответ, содержащий информацию о номере полученного фрагмента;
2. Когда мы получаем фрагмент с номером n, необходимо отправить ACK на фрагмент с номером n + 1;
3. Если до получателя не дойдет фрагмент или до отправителя не дойдет ACK, то по истечении некоторого TL нужно отправить фрагмент повторно.

В такой вариации можно не хранить вообще никаких вспомогательных данных, но протокол ломается, если ACK приходит позже, чем проходит TL на его ожидание. Тогда мы многократно будем отсылать одни и те же фрагменты. Чтобы исправить эту проблему, в RFC 1350 добавили следующее правило: если на какой-то фрагмент уже приходил ACK, то его не нужно отправлять повторно.

### TCP

**TCP** (*Transmission Control Protocol*) - RFC 793, 1122, 2018, 5681, 7323 - один из основных протоколов передачи данных интернета. Предназначен для управления передачей данных интернета. Пакеты в TCP называются *сегментами*. Механизм TCP представляет собой поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери и устраняет дублирование при получении двух копий одного пакета, гарантируя тем самым (в отличие от UDP) целостность передаваемых данных и уведомление отправителя о результатах передачи.

**Примечание**: Клиент отправляет серверу ACK'и как подтверждение, что он получил сегменты. При этом он не обязан присылать по ACK'у на каждый сегмент, вполне допустимое поведение присылать ACK только на последний полученный сегмент.

![TCP Header](./images/tcp-header-structure.jpg "TCP Header")

**Congestion Window** - кол-во сегментов, которые были отправлены, но ACK'и на которые пока не были получены. Это значение необходимо подбирать: если отправлять слишком много, то какие-то начнут теряться, если по одному, получится TFTP. Для подбора используется следующий алгоритм:
1. Начинаем отправлять по одному сегменту;
2. Если все пакеты доходят, то увеличиваем число пакетов в два раза и делаем так, пока пакеты не начнут теряться;
3. Как только пакеты теряются - у нас есть два значения: 2^n и 2^(n - 1). Далее запускаем бинарный поиск оптимального значения между ними.

Пока вопрос о том, как понимать, что пакеты теряются, остается открытым. Если клиент получает сегменты с пропусками, то он может подождать (условных 10 мс), а затем отправить повторно ACK на последнюю позицию, до которой нет пропусков. Таким образом, для сервера повторное получение ACK'а на одну и ту же позицию является сигналом, что пакеты начали теряться. К тому же сервер узнает, начиная с какой позиции надо перепослать сегменты и перепошлет их сразу, не дожидаясь TL. Такой подход называется **TCP Fast Retransmission**.

Далее размер Congestion Window определяется с помощью функции **AIMD** (*Additive increase, multiplicative decrease*) (это один из вариантов, а остальные рассматриваются в рамках следующей лекции). Если всё хорошо, то к нему прибавляется 1, как только всё плохо - значение делится на 2:

![AIMD Graph](./images/tcp-congestion-window.png "Congestion Window")

## Лекция 5. Подробнее о TCP

**Selective acknowledgment** - механизм, позволяющий указать ACK промежутками, чтобы сообщить, что не надо посылать все повторно во время fast restransmission, а достаточно переслать только часть из них.

Также в TCP существуют альтернативные подходы к определению Window size (помимо AIMD):
1. **TCP BIC** (*Binary Increase Congestion control*)
2. **TCP CUBIC**
3. **TCP Reno**
4. **TCP BBR** (*Bottlenech Bandwidth and Round-trip propagation time*) - алгоритм, предложенный Google в 2016 году, который основывается не на потерях пакета, а на скорости получения ACK'ов на них.
5. **ECN** (*Explicit congestion notification*) - подход, при котором получатель присылает флаг, обозначающий, что отправитель шлет слишком много. Для этого есть специальный TCP-флаг `ECE` (*ECN-Echo*). Он проставляется получателем до тех пор, пока отправитель не проставит флаг `CWR` (*Congestion Window Reduced*).

TCP BIC:
![TCP BIC](./images/tcp-bic.png "TCP BIC")

TCP CUBIC:
![TCP CUBIC](./images/tcp-cubic.png "TCP CUBIC")

### TCP Flow Control

Помимо того, что узкие места могут быть по пути между отправителем и получателем (маленькие очереди, в которых теряются пакеты), сам получатель может иметь небольшой буфер и он бы хотел, чтобы этот буфер не переполнился. Таким образом, с точки зрения TCP все хорошо, но сервер должен отправлять данные помедленнее.

**TCP Window size** - это количество байтов, которое принимающая сторона *готова* принять в настоящий момент без подтверждения.

Таким образом, отправитель должен отправлять минимум из Congestion Window и TCP Window size, чтобы TCP работал эффективно.

**Примечание**: TCP-сегмент содержит опции и одна из них - Window scale. Она указывает на степень двойки, на которую всегда помножается *Window size* (очень удобно поддерживать большие числа).

**Примечание**: В опциях TCP-сегмента есть доп. опция Timestamps, которая является костылем, решающим проблему с тем, что sequence number может переполняться (32-битное число - это не очень много). Если он переполняется, то без Timestamp'ов не отличить, пришел ли сегмент с новым номером или с номером на ~ четыре миллиона меньше.

### Установка соединения

Установка соединения в TCP работает по алгоритму 3-Way Handshake. В двух первых пакетах выставляется флаг `SYN` (*syncronization*) и передаются некоторые опции: `Seq`, `Win` и так далее. Второй и третий пакеты - это `ACK`'и, указывающие на то, что и отправитель, и получатель узнали необходимую информацию.

![TCP 3-Way Handshake](./images/tcp-3-way-handshake.jpg "TCP 3-Way Handshake")

Поскольку `SYN` мог быть отправлен с фейкового IP-адреса, получатель не хочет принимать данные сразу, так как для этого надо выделять место под сложные структуры данных и многое запоминать. Поэтому он сначала дожидается, что отправитель `SYN`'а примет его `SYN-ACK`, распарсит TCP-сегмент и пришлет `ACK`. Это дает минимальную защиту для получателя. Однако, ему все еще приходится выделять 4 байта на sequence number. Чтобы этого не делать, на самом деле используются SYN Cookie и это число вычисляется на лету на основании IP-адреса отправителя, минуты и тому подобного.

### Закрытие соединение

Для закрытия соединения используются также модель 3-Way Handshake, но с `FIN`, `FIN-ACK` и `ACK`:

![TCP Connection Termination](./images/tcp-3-way-handshake-connection-termination.jpg "TCP Connection Termination")

**Замечание**: У TCP нет защиты от злоумышленников (да и все протоколы, о которых мы уже говорили основаны на **доверии**), так что если он получит sequence number, сможет подменить трафик и угадает длину сегмента (если не угадает, то отправитель получит ACK в странное место и закроет соединение), то он сможет подменять данные.

## Лекция 6. DNS

Люди плохо запоминают числа и им хочется заходить на docs.google.com, а не на непонятные числа. Первый подход к решению этой задачи - файлик `/etc/hosts`, в котором написано отображение строковых имен в IP-адреса. Главные недостатки - сложность обновления и объем. Поэтому было принято решение сделать такую же систему, но глобальную. Описать её получилось буквально в нескольких RFC: 1035, 1101, 1183, 1348, 1876, 1982, 1995, 2065, 2136, 2181, 2137, 2308, 2673, 2845, 3425, 3658, 4033, 4034, 4035, 4343, 5936, 5966, 6604, 7766, 8482, 8490, 8767.

**DNS** (*Domain Name System*) - компьютерная распределенная система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста, получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене. Label не превышает 63 символа, name не более 254 символов, содержать может строчные и заглавные латинские буквы, цифры и тире.

**IDN** (*Internationalized domain name*) - RFC 5890, 5891 - костыль, который позволяет преобразовывать не подходящие символы в подходящие для DNS (альфанумерики). Например, `итмо.ру` преобразуется в `xn--h1aigo.xn--p1ag` (очень удобно). Выполнять такие преобразования можно, например, Linux-утилитой `idn`.

При разработке DNS нельзя было просто сделать один файл со всеми доменными именами, так как он бы получился слишком большим и им было бы тяжело управлять, поэтому DNS имеет иерархическую структуру (доменные имена надо читать справа налево):

![DNS Hierarchy Structure](./images/dns-hierarchy-structure.png "DNS Hierarchy Structure")

DNS позволяет получать не только IP-адреса, но и некоторую мета-информацию (*resource records*):
- `A` (*Address*) - адрес в формате IPv4.
- `AAAA` (*A+1+1+1*) - адрес в формате IPv6.
- `CNAME` (*Canonical name*) - каноническое (альтернативное) имя для псевдонима домена (одноуровневая переадресация); для написания национальными символами.
- `PTR` (*Pointer*) - соответствие адреса — имени: обратное соответствие для `A` и `AAAA`.
- `TXT` (*Text string*) - запись произвольных двоичных данных, до 255 байт в размере.
- `MX`(*Mail Exchanger*) - адрес почтового шлюза для домена: состоит из двух частей — приоритета (чем число больше, тем ниже приоритет), и адреса узла.
- `LOC` (*Location information*) - географическое местоположение домена.
- `NS` (*Authoritative name server*) - адрес узла, отвечающего за доменную зону: критически важна для функционирования самой системы доменных имён.
- `SOA` (*Start of authority*) - указание на авторитетность информации, используется для указания на новую зону. Содержит полезную информацию, такую как TTL кэширования негативного ответа. Все поля: `Serial`, `Refresh`, `Retry`, `Expire`, `Negative Cache TTL`.

**Примечание**: Чтобы получить resource records от DNS сервера, можно использовать Linux-утилиту `dig`.

**Корневые DNS серверы** - DNS-серверы (`a.root-servers.net` - `m.root-servers.net`), обеспечивающие работу корневой зоны DNS в сети Интернет. Содержат информацию о региональных зонах (`ru.`, `com.` и так далее).

**Рекурсивный DNS сервер** (*recursive resolver*) - DNS-сервер, который сам проходит по всех иерархии DNS-серверов, начиная с корневых (если у него не закэшированы их ответы), возвращает запрашиваемый IP-адрес и даже кэширует его. Пример рекурсивного DNS-сервера - `8.8.8.8`.

**Примечание**: DHCP возвращает адреса рекурсивных DNS серверов в опции `domain-name-servers`.

Протокол DNS поддерживает такую функцию как трансфер зоны, что позволяет раздать всю известную информацию на соседние DNS-сервера (например, `dig -t AXFR google.com @ns1.google.com`), однако обычно эта информация не публичная (на команду из примера Google не ответит).

**Примечание**: DNS работает поверх UDP.

**Структура DNS протокола**:

![DNS Protocol](./images/dns-protocol-structure.png "DNS Protocol")

**Примечание**: DNS по умолчанию не безопасный и провайдер может не просто видеть DNS запросы, но и фильтровать их по содержимому. Большинство DNS трафика не зашифровано, а шифроваться трафик может только при обращении к рекурсивному DNS-серверу.

Для транспорта DNS можно использовать следующие подходы:
- UDP port 53
  - Ограничен 512-ю байтами
- TCP port 53
- DNS over TLS (DoT)
  - RFC 7858
- DNS over HTTPS (DoH)
  - RFC 8484

## Лекция 7. Подробнее про DNS. HTTP

### Reverse DNS

**Обратный просмотр DNS** (англ. *reverse DNS lookup*) — обращение к особой доменной зоне для определения имени узла по его IP-адресу c помощью `PTR`-записи.

Для выполнения запроса адрес узла переводится в обратную нотацию, способ перевода зависит от версии IP:
- IPv4-адрес `192.168.0.1` превращается в `1.0.168.192.in-addr.arpa.`;
- IPv6-адрес `2001:db8::567:89ab` — в `b.a.9.8.7.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa.`.

Благодаря иерархической модели управления именами появляется возможность **делегировать** управление зоной владельцу диапазона IP-адресов. Для этого в записях авторитетного DNS-сервера указывают, что за зону `CCC.BBB.AAA.in-addr.arpa` (то есть за сеть `AAA.BBB.CCC.000/24`) отвечает отдельный сервер.

**Пример**: DNS-запись `in-addr.arpa` выглядит так:
```
56.34.12.10.in-addr.arpa. IN PTR host1.example.net.
```

**Примечание**: В протоколе DNS в additional info можно сообщить, с какой *примерно* сети пришел клиент, и выдавать ему адрес ближайшего к нему сервера. Это позволяет решить проблему, когда кто-то из Австралии запросил адрес google.com, а рекурсивный сервер, который обслуживает весь мир закэшировал ответ и выдавал его затем всем из Европы.

### DNS Cache poisoning

Процесс атаки:

![DNS Cache Poisoning Process](./images/dns-cache-poisoning-attack.svg "DNS Cache Poisoning Process")

Результат:

![Poisoned DNS Cache](./images/dns-cache-poisoned.svg "Poisoned DNS Cache")

**Способы решения уязвимости**:
1. Отправлять cookie. Протокол DNS содержит не очень много возможностей для этого, однако он регистронезависимый, так что можно спрашивать не про google.com, а про gOOgLe.coM (случайная капитализация), а затем проверять, для того же ли домена пришел ответ;
2. Всегда делать запрос по TCP;
3. Писать что-то в identification.
4. DNSSEC.

### DNSSEC

**DNSSEC** (*Domain Name System Security Extensions*) - набор расширений IETF протокола DNS, позволяющих минимизировать атаки, связанные с подменой IP-адреса при разрешении доменных имён. Он направлен на предоставление DNS-клиентам (англ. термин resolver) гарантии достоверности и целостности данных.

DNS-сервера генерируют пару из публичного и приватного ключа и просят корневые сервера подписывать их, благодаря чему могут доказать, что публичный ключ принадлежит именно им. Затем DNS-cервера подписывают свои ответы.

**Замечание**: DNSSEC не обеспечивает конфиденциальность данных; в частности, все DNSSEC ответы аутентифицированы, но **ответы не шифруются**. DNSSEC не защищает от DoS-атак непосредственно, хотя в некотором роде делает это косвенно. Для обеспечения защиты необходимо использовать сторонние методы.

RRs:
- `DNSKEY` - public key сервера
- `RRSIG` - signature
- `DS` - DNSSEC delegation o another zone
- `NSEC`/`NSEC3` - имени не существует

### Регистрация доменного имени

Домены верхнего уровня:
- `.com`, `.org`, `.net`, `.int`, `.edu`, `.gov`, `.mil`
- `.ru`, `.us`, `.io`, `.me`, `.tv`, ...
- `.рф`, `.الجزائر`, ...
- `.football`, `.bar`, `.flowers`, `.google`, `.moscow`, `.москва`
- [Root Zone Database](https://www.iana.org/domains/root/db)

Чтобы зарегистрировать домен второго уровня, необходимо обратиться в организацию-регистратор, у которой заключен договор с владельцами доменов первого уровня. Регистратор внесет домен второго уровня в базу данных, а именно, `NS` записи для данного домена.

**Примечание**: Домены не покупают, их *арендуют*. Посмотреть, на какой срок оплачен домен, можно с помощью утилиты `whois`: поле `paid-till`. Также можно посмотреть, например, контактную информацию о владельце домена.

### HHTP

**HTTP** (*HyperText Transfer Protocol* — *протокол передачи гипертекста*) — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

**Пример**: HHTP запрос, скачивающий заявление на отчисление по собственному желанию:
```
igor@acer:~$ nc neerc.ifmo.ru 80 > Downloads/lgd.pdf
GET /lgd.pdf HTTP/1.1
Host: neerc.ifmo.ru

^C
igor@acer:~$ ls -lh ~/Downloads/lgd.pdf
-rw-rw-r-- 1 igor igor 272K июн 17 14:05 /home/igor/Downloads/lgd.pdf
```

**URI** (*Uniform Resource Identifier*) - унифицированный (единообразный) идентификатор ресурса. URI — последовательность символов, идентифицирующая абстрактный или физический ресурс. Ранее назывался *Universal Resource Identifier* — универсальный идентификатор ресурса.

Структура URI (Википедия):
```
URI = [ схема ":" ] иерархическая-часть [ "?" запрос ] [ "#" фрагмент ]
```

**URL** (*Uniform Resource Locator* - *унифицированный указатель ресурса*) — система унифицированных адресов электронных ресурсов, или единообразный определитель местонахождения ресурса (файла).

Структура URL:
```
scheme:[//[user[:password]@]host[:port]]path[?query][#fragment]
```

**Примечание**: Не вдаваясь в подробности **URL** - это подмножество URI для веб-страниц.

HTTP Methods:
- `GET` - используется для запроса содержимого указанного ресурса. С помощью метода `GET` можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Согласно стандарту HTTP, запросы типа `GET` считаются *идемпотентными*;
  - Условный `GET` - содержит заголовки `If-Modified-Since`, `If-Match`, `If-Range` и подобные;
  - Частичный `GET` - содержит в запросе `Range`;
- `HEAD` - аналогичен методу `GET`, за исключением того, что в ответе сервера отсутствует тело. Запрос `HEAD` обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения;
- `POST` - применяется для передачи пользовательских данных заданному ресурсу. Например, при авторизации пользователь вводит свои учетные данные в HTML-форму, после чего они передаются серверу методом `POST`. При этом передаваемые данные (в примере с авторизацией — учетные данные) включаются в тело запроса. Аналогично с помощью метода `POST` обычно загружаются файлы на сервер. В отличие от метода `GET`, метод `POST` не считается идемпотентным, то есть многократное повторение одних и тех же запросов `POST` может возвращать разные результаты;
- `PUT` - применяется для загрузки содержимого запроса на указанный в запросе URI;
- `PATCH` - аналогично `PUT`, но применяется только к фрагменту ресурса;
- `DELETE` - удаляет указанный ресурс;
- `TRACE`- возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе;
- `OPTIONS` - используется для передачи возможностей веб-сервера или конкретного ресурса.
- `CONNECT`- преобразует соединение запроса в прозрачный TCP/IP-тунель, обычно чтобы содействовать установлению защищенного SSL-соединения через нешифрованный прокси;

**Коды состояния** (*HTTP Responses*):
1. Информационные (*informational*):
   - `100`: Continue;
   - `101`: Switching Protocols;
   - `102`: Processing;
   - `103`: Early Hints;
2. Успех (*successful*):
   - `200`: **OK** - успешный запрос;
   - `201`: Created;
   - `202`: Accepted;
   - `203`: Non-Authoritative Information;
   - `204`: **No Content** - сервер успешно обработал запрос, но в ответе были переданы только заголовки без тела сообщения;
   - `205`: Reset Content;
   - `206`: Partial Content;
   - `207`: Multi-Status *(HTTP/2)*;
   - `208`: Already Reported *(HTTP/2)*;
   - `226`: IM Used *(HTTP/2)*;
3. Перенаправление (*redirection*):
   - `300`: Multiple Choices;
   - `301`: **Moved Permanently** - запрошенный документ был окончательно перенесен на новый URI, указанный в поле `Location` заголовка;
   - `302`: **Found** - запрошенный документ временно доступен по другому URI, указанному в заголовке в поле `Location`;
   - `303`: See Other;
   - `304`: **Not Modified** - сервер возвращает такой код, если клиент запросил документ методом GET, использовал заголовок If-Modified-Since или If-None-Match и документ не изменился с указанного момента. При этом сообщение сервера не должно содержать тела;
   - `305`: Use Proxy;
   - `307`: **Temporary Redirect** - запрашиваемый ресурс на короткое время доступен по другому URI, указанный в поле `Location` заголовка;
   - `308`: Permanent Redirect *(HTTP/2)*;
4. Ошибка клиента (*client error*):
   - `400`: **Bad Request** - сервер обнаружил в запросе клиента синтаксическую ошибку;
   - `401`: **Unauthorized** - для доступа к запрашиваемому ресурсу требуется аутентификация. В заголовке ответ должен содержать поле `WWW-Authenticate` с перечнем условий аутентификации. Иными словами, для доступа к запрашиваемому ресурсу клиент должен представиться, послав запрос, включив при этом в заголовок сообщения поле `Authorization` с требуемыми для аутентификации данными. Если запрос уже включает данные для авторизации, ответ `401` означает, что в авторизации с ними отказано;
   - `402`: Payment Required;
   - `403`: **Forbidden** - сервер понял запрос, но он отказывается его выполнять из-за ограничений в доступе для клиента к указанному ресурсу. Иными словами, клиент не уполномочен совершать операции с запрошенным ресурсом. Если для доступа к ресурсу требуется аутентификация средствами HTTP, то сервер вернёт ответ `401`, или `407` при использовании прокси. В противном случае ограничения были заданы администратором сервера или разработчиком веб-приложения и могут быть любыми в зависимости от возможностей используемого программного обеспечения;
   - `404`: **Not Found** - ошибка в написании адреса Web-страницы. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URL;
   - `405`: Method Not Allowed;
   - `406`: Not Acceptable;
   - `407`: Proxy Authentication Required;
   - `408`: Request Timeout;
   - `409`: Conflict;
   - `410`: Gone;
   - `411`: Length Required;
   - `412`: Precondition Failed;
   - `413`: Payload Too Large;
   - `414`: URI Too Long;
   - `415`: Unsupported Media Type;
   - `416`: Range Not Satisfiable;
   - `417`: Expectation Failed *(HTTP/2)*;
   - `418`: *I'm a teapot* *(HTTP/2)*;
   - `419`: Authentication Timeout *(HTTP/2)*;
   - `421`: Misdirected Request *(HTTP/2)*;
   - `422`: Unprocessable Entity *(HTTP/2)*;
   - `423`: Locked *(HTTP/2)*;
   - `424`: Failed Dependency *(HTTP/2)*;
   - `425`: Too Early *(HTTP/2)*;
   - `426`: Upgrade Required *(HTTP/2)*;
   - `428`: Precondition Required *(HTTP/2)*;
   - `429`: Too Many Requests *(HTTP/2)*;
   - `431`: Request Header Fields Too Large *(HTTP/2)*;
   - `449`: Retry With *(HTTP/2)*;
   - `451`: Unavailable For Legal Reasons *(HTTP/2)*;
   - `499`: Client Closed Request *(HTTP/2)*;
5. Ошибка сервера (*server error*):
   - `500`: **Internal Server Error** любая внутренняя ошибка сервера, которая не входит в рамки остальных ошибок класса;
   - `501`: Not Implemented;
   - `502`: **Bad Gateway** - сервер, выступая в роли шлюза или прокси-сервера, получил недействительное ответное сообщение от вышестоящего сервера;
   - `503`: Service Unavailable;
   - `504`: Gateway Timeout;
   - `505`: HTTP Version Not Supported;
   - `506`: Variant Also Negotiates *(HTTP/2)*;
   - `507`: Insufficient Storage *(HTTP/2)*;
   - `508`: Loop Detected *(HTTP/2)*;
   - `508`: Resource Limit Reached *(HTTP/2)*;
   - `509`: Bandwidth Limit Exceeded *(HTTP/2)*;
   - `510`: Not Extended *(HTTP/2)*;
   - `511`: Network Authentication Required *(HTTP/2)*;
   - `520`: Unknown Error *(HTTP/2)*;
   - `521`: Web Server Is Down *(HTTP/2)*;
   - `522`: Connection Timed Out *(HTTP/2)*;
   - `523`: Origin Is Unreachable *(HTTP/2)*;
   - `524`: A Timeout Occurred *(HTTP/2)*;
   - `525`: SSL Handshake Failed *(HTTP/2)*;
   - `526`: Invalid SSL Certificate *(HTTP/2)*;

При формировании запроса клиент передает набор заголовков. В ответе сервер также пишет заголовки.

Примеры заголовков в запросе:
- `Host: neerc.ifmo.ru`
- `Connection: Keep-Alive`
- `Accept-Encoding: gzip,deflate`
- `Accept-Languages: en-US,ru-RU`

Примеры заголовков в ответе:
- `Content-Encoding: gzip`
- `Content-Language: en`
- `Content-Type: text/html`
- `Content-Length: 14`
- `Transfer-Encoding: gzip`
- `Refresh:	5; url=http://www.example.com/`
- `Last-Modified: Wed, 24 Mar 1994 08:45:26 GMT`
- `ETag: "123-a"`

**Условные HTTP запросы** (англ. *conditional HTTP request*) - это такие HTTP запросы, которые выполняются по-разному, в зависимости от значения особых заголовков. Эти заголовки определяют предусловие (*precondition*), и результат будет разным, если условие согласовано или нет.

Заголовки условных HTTP запросов:
- `If-Match`: `ETag` удаленного ресурса равен одному из переданных в данном заголовке;
- `If-None-Match`: `ETag` удаленного ресурса отличается от всех переданных в данном заголовке.
- `If-Modified-Since`: `Last-Modified` удаленного ресурса больше, чем переданный в данном заголовке.
- `If-Unmodified-Since`: `Last-Modified` удаленного ресурса меньше или равен, чем переданный в данном заголовке.
- `If-Range: "W/aasdasd"` Аналогичен `If-Match` или `If-Unmodified-Sence`, но может содеражать только один etag или timestamp.

**Запросы по кускам** (англ. *range requests*) - запросы, которые относятся только к части документа.

Заголовки для range request'ов:
- `Accept-Ranges`: маркер, который использует *сервер*, чтобы уведомить клиента о поддержке "запросов по кускам". Примеры: `Accept-Ranges: none`, `Accept-Ranges: bytes`;
- `Range`: указывает серверу какую часть документа ему необходимо вернуть. Пример: `Range: bytes 21010-47021`.
- `Content-Range`: указывает на то, какую часть документа вернул *сервер* и какая общая длина документа. Пример: `Content-Range: bytes 21010-47021/47022`.

Примеры заголовков для кэширования ответов:
- От клиента:
  - `Cache-Control: max-age=3600`
  - `Cache-Control: no-cache`
  - `Cache-Control: only-if-cached`
  - `Pragma: no-cache`
- От сервера:
  - `Age: 300`
  - `Expires: Thu, 01 Dec 1994 16:00:00 GMT`

`User-Agent` - заголовок, который содержит такую информацию, как название и версия приложения, операционная система компьютера и язык. По факту обычно *в браузерах* это выглядит как `Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36`. Так исторически сложилось, что для Mozila обычно возвращали веб-страничку получше.

**Примечание**: Чтобы делать запросы можно использовать утилиту `curl`:
```
igor@acer:~$ curl --verbose --request GET --header "Range: bytes=0-99" --header "Connection: close" http:/neerc.ifmo.ru/lgd.pdf --output ~/Downloads/lgd.pdf
Note: Unnecessary use of -X or --request, GET is already inferred.
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 77.234.215.132:80...
* TCP_NODELAY set
* Connected to neerc.ifmo.ru (77.234.215.132) port 80 (#0)
> GET /lgd.pdf HTTP/1.1
> Host: neerc.ifmo.ru
> User-Agent: curl/7.68.0
> Accept: */*
> Range: bytes=0-99
> Connection: close
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 206 Partial Content
< Server: nginx
< Date: Sat, 17 Jun 2023 12:52:02 GMT
< Content-Type: application/pdf
< Content-Length: 100
< Last-Modified: Tue, 11 Dec 2018 12:53:55 GMT
< Connection: close
< ETag: "5c0fb363-43e96"
< Access-Control-Allow-Origin: *
< Access-Control-Allow-Methods: GET, POST, OPTIONS, PUT, DELETE
< Content-Range: bytes 0-99/278166
<
{ [100 bytes data]
100   100  100   100    0     0   2631      0 --:--:-- --:--:-- --:--:--  2631
* Closing connection 0
```
## Лекция 8. Cookies. HTTP/2,3. HTTPS

### Cookies

**Cookies** (*куки*) - небольшие фрагменты данных, отправляемые веб-сервером и хранимые на компьютере пользователя. Веб-клиент всякий раз при попытке открыть страницу соответствующего сайта пересылает эти фрагменты данных веб-серверу в составе HTTP-запроса (заголовок `Set-Cookie`). Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:
- аутентификации пользователя;
- хранения персональных предпочтений и настроек пользователя;
- отслеживания состояния сеанса доступа пользователя;
- хранения сведений статистики о пользователях.

Cookies могут содержать параметры (перечислены не все):
- `HttpOnly` - параметр запрещает доступ к cookie посредством API `document.cookie` (JS). Эта возможность была предложена в качестве меры для эффективного предотвращения краж cookie посредством XSS-атак.
- `Secure` - параметр указывает браузеру, что cookie должны передаваться на сервер только по защищённому HTTPS-соединению;
- `Domain` - отмечает, какой домен или поддомен имеет доступ к этой cookie. Не может быть доменом первого уровня, а также доменом, в котором разные люди могут регистрировать сайты. Если указывает не на домен, отличный от `Host`, то требуется доп. разрешение на third party cookie.

### HTTP/2

**SPDY** (*speedy*) - протокол прикладного уровня передачи веб-контента, разработанный корпорацией Google. По замыслу разработчиков, данный протокол позиционируется как замена некоторых частей протокола HTTP - таких, как управление соединениями и форматы передачи данных. Широко использовался с 2011-2012 годов. Но поскольку с 2015 года активно внедрялся протокол HTTP/2, поддержка протокола SPDY была удалена из ряда клиентов в 2016 году в пользу HTTP/2.

**HTTP/2** (изначально - *HTTP/2.0*) - вторая версия протокола HTTP, основанная на SPDY (первый черновик HTTP/2 представлял собой копию спецификации SPDY). Основные изменения относительно HTTP/1.0 и HTTP/1.1:
- **Multiplexing** (*мультиплексирование*) - мультиплексированная асинхронная передача данных: на одном соединении запросы разделяются на чередующиеся пакеты, сгруппированные в отдельные потоки.
- **Server push** - право сервера послеть то содержимое, которое еще не было запрошено клиентом. Позволило серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.
- Реализовано сжатие HTTP-заголовков. Каждый отправленный заголовок содержит информацию об отправителе и получателе, а это – избыточные объёмы. Благодаря сжатию полная информация отправляется только в первом заголовке, в последующих отправленных заголовках такой информации уже нет.
- В отличие от текстового протокола HTTP, HTTP/2 - бинарный. Благодаря этому можно обрабатывать небольшие сообщения, из которых формируются более крупные.
- Запросы приоритизируются, благодаря чему снимается проблема с одновременной отправкой всех запросов.

![HTTP/2 Server Push](./images/http2-server-push.webp "HTTP/2 Server Push")

### HTTP/3

**HTTP/3** (ранее известный как *HTTP-over-QUIC*) — готовящаяся к публикации третья версия HTTP, наследница HTTP/2. HTTP/3 в настоящее время (07.2023) находится в стадии черновика и основан на предыдущем черновике RFC «Hypertext Transfer Protocol (HTTP) over QUIC».

**QUIC** — экспериментальный сетевой протокол транспортного уровня, разработанный в 2012 году компанией Google.

QUIC позволяет мультиплексировать несколько потоков данных между двумя компьютерами, работая поверх протокола UDP, и содержит возможности шифрования, эквивалентные TLS и SSL. Имеет более низкую задержку соединения и передачи, чем TCP. Хорошо переносит потерю части пакетов путём выравнивания границ криптографических блоков по границам пакетов. В протокол заложена возможность прямой (упреждающей) коррекции ошибок на уровне пакетов, но на практике она отключена.

### HTTPS

**Криптографическая система с открытым ключом** — система шифрования и/или электронной подписи (ЭП), при которой открытый ключ передаётся по открытому (то есть незащищённому, доступному для наблюдения) каналу и используется для проверки ЭП и для шифрования сообщения. Для генерации ЭП и для расшифровки сообщения используется закрытый ключ.

**Иллюстрация работы электронной цифровой подписи**:

![Digital Signature](./images/digital-signature.png, "Digital Signature Algorithm")

**Шифрование с открытым ключом**:

![Encription](./images/public-key-encryption.png "Encription")

**Протокол Диффи-Хеллмана** (англ. *Diffie–Hellman key exchange protocol*, *DH*) — криптографический протокол, позволяющий двум и более сторонам получить общий секретный ключ, используя незащищенный от прослушивания канал связи. Полученный ключ используется для шифрования дальнейшего обмена с помощью алгоритмов симметричного шифрования.

**Иллюстрация работы протокола Диффи-Хеллмана**:

![Deffie-Hellman Key Exchange](./images/dh-revised.png "Heffie-Helmann Key Exchange")

**Примечание**: Алгоритм Диффи-Хеллмана уязвим для атаки Man-in-the-middle:

![Deffie-Hellman Man-in-the-middle attack](./images/dhe-mitm.png "Deffie-Hellman Man-in-the-middle attack")

Когда мы подключаемся к серверу, сервер сразу отправляет свой публичный ключ. Далее можно воспользоваться этим публичным ключом, чтобы убедиться, что у нас нет человека посередине, сгенерировать *сессионный ключ* с помощью алгоритма Диффи-Хеллмана и дальше шифровать всё с помощью него. Главный здесь вопрос - как убедиться, что публичный ключ, который мы получаем, действительно принадлежит серверу (man-in-the-middle мог его подменить)?

Для этого нужно, чтобы публичный ключ был *заверен*. Доверяем мы, например, компаниям, которые перечислены в `/etc/ssl/certs` в Lunux. У Google Chrome есть свой список доверенных компаний. Этим компании (**CA**) могут заверять публичные ключи и выдавать сертификаты.

**Центр сертификации** или **удостоверяющий центр** (англ. *Certification authority*, *CA*) — сторона (отдел, организация), чья честность неоспорима, а открытый ключ широко известен. Задача центра сертификации — подтверждать подлинность ключей шифрования с помощью сертификатов электронной подписи. Если CA подписывает публичный ключ сервера с помощью свого приватного ключа, то с помощью публичного ключа CA можно проверить подлинность этой электронной подписи, а значит, можно доверять публичному ключу сервера.

Чтобы проверить, можно ли выдать серверу сертификат, можно использовать следующие подходы:
1. Попросить добавить какую-то TXT запись в настройки DNS-сервера;
2. Попросить добавить на сервер веб-страницу с каким-нибудь текстом.

**Протокол TLS** (*transport layer security* — *протокол защиты транспортного уровня*), как и **протокол SSL** (*Secure Sockets Layer* — *уровень защищённых сокетов*) — криптографические протоколы, обеспечивающие защищённую передачу данных между узлами в сети Интернет. TLS и SSL используют асимметричное шифрование для аутентификации, симметричное шифрование для конфиденциальности и коды аутентичности сообщений для сохранения целостности сообщений.

**Примечание**: Формально это всё-таки два разных протокола - в 2014 году правительство США сообщило об уязвимости в текущей версии SSL, поэтому он должен быть исключён из работы в пользу TLS (см. CVE-2014-3566). Однако TLS-протокол основан на спецификации протокола SSL версии 3.0, так что является его прямым наследником.

История SSL и TLS (в зачеркнутых нашли уязвимости):
- ~~SSL (Secure Sockets Layer)~~
- ~~SSL 2.0~~
- ~~SSL 3.0~~
- ~~TLS 1.0~~
- ~~TLS 1.1~~
- TLS 1.2 (RFC 5246)
- TLS 1.3 (RFC 8446)

**Сертификат TLS/SSL** – это цифровой сертификат, удостоверяющий подлинность веб-сайта и позволяющий использовать зашифрованное соединение.

**Структура сертификата**:
- Subject
  - Common Name (CN)
- Issued On
- Expires On
- Subject Alternative Names
- Wildcard
  - `*.google.com`
    - docs.google.com
    - ~~www.docs.google.com~~ - '*' соответствует только одному уровню домена.

**Сессионные ключи** — ключевая информация в криптографии, вырабатываемая между двумя пользователями для защиты канала связи. Обычно сеансовым ключом является общий секрет — информация, которая вырабатывается на основе секретного ключа одной стороны и открытого ключа другой стороны.

Сессионные ключи помогают решить две основные задачи:
1. Ограничение количества информации, зашифрованной на одном ключе. Это снижает возможности атакующего по применению ряда криптоаналитических методик, которые требуют большого объема перехваченной информации.
2. Ускорение работы в системах с применением асимметричной криптографии.

Для шифрования данных согласно протоколу TLS можно использовать RSA или сессионные ключи, сгенерированные согласно алгоритму Диффи-Хеллмана. В версии TLS 1.3 форсится использование *только* по алгоритму Диффи-Хеллмана, так как это позволяет увеличить Forward secrecy.

**Perfect forward secrecy** (рус. *совершенная прямая секретность*) - свойство некоторых протоколов согласования ключа, которое гарантирует, что сессионные ключи, полученные при помощи набора ключей долговременного пользования, не будут скомпрометированы при компрометации одного из долговременных ключей.

Иногда бывают такие ситуации, когда сертификаты выпускаются для домена без ведома его владельца. Чтобы этого избежать, существует экспериментальный открытый стандарт - **Certificate Transparency**. Согласно ему при выдаче сертификата CA должны делать публичные уведомления при выдаче любого сертификата. Посмотреть все выданные сертификаты можно на сайте [crt.ru](https://crt.sh/). Если CA не уведомит организации, которые занимаются certificate transparency, то когда кто-то зайдет на сайт с таким сертификатом и обнаружит, что сертификата нет в соответствующих БД, эта организация потеряет доверие и её удалят из списков операционных систем и браузеров.

Альтернативный вариант - сделать DNS-запись CAA (Certification Authority Authorization), указывающую, какая именно организация может выдавать сертификаты для домена. Например:
```
melnikov.ch. 59  IN  CAA 128 issue "letsenprypt.org
```
**ACME** (*Automatic Certificate Management Environment*) - протокол, который применяется для организации взаимодействия удостоверяющего центра и web-сервера, автоматизации получения и обслуживания сертификатов. Например, существуют certbot'ы, которые позволяют за условные 15 минут сделать на своем сайте HTTPS и больше не думать об этом.

**SNI** (*Server Name Indication*) - расширение TLS, которое позволяет клиенту сообщать имя хоста, с которым он желает соединиться во время процесса «рукопожатия». Это позволяет серверу предоставлять несколько сертификатов на одном IP-адресе и TCP-порте, и, следовательно, позволяет работать нескольким безопасным (HTTPS-) сайтам на одном IP-адресе без использования одного и того же сертификата на всех сайтах. Запрашиваемое имя хоста не шифруется, что позволяет злоумышленнику его перехватить.

**ENSI** (*Encrypted SNI*) - расширение TLS 1.3, которое позволяет при подключении получить какой-то сертификат, с помощью которого затем можно запустить новое соединение и подписывать SNI этим сертификатом и получать сертификат для нужного домена.

**ECH** (*Encrypted Client Hello*) - расширение, при котором сертификат можно класть прямо в настройки DNS.

![ESNI and ECH](./images/esni-and-ech.png "ESNI and ECH")

По умолчанию все подключаются сначала по HTTP. Однако, если клиент хотя бы раз подключался по HTTPS, то можно применить **HSTS** и таким образом сообщить клиенту, что в будущем он должен подключаться только по HTTPS.

**HSTS** (*HTTP Strict Transport Security*) - механизм, принудительно активирующий защищённое соединение через протокол HTTPS. Реализуется благодаря следующему заголовку: `Strict-Transport-Security: max-age=63072000; includeSubDomains; preload`.

**Примечание**: Чтобы пользователи сразу подключались по HTTPS можно захардкодить в нескольких JSON'ах (на лекции было упомянуто 3: Apple, Microsoft и Chrome) свой сайт. Пример для Google Chrome: `transport_security_state_static.json`.

**CRL** (*certificate revocation list*) - список потерявшихся сертификатов. Туда надо добавлять свой сертификат, если он "утек".

**OCSP** (*online certificate status protocol*) - протокол, позволяющий клиенту попросить у сервера справку о том, что сертификат действителен, совсем недавно выданую центром сертификации (CA).

**TLS Session Resumption** - возможность сэкономить некоторое время на старте и не генерировать сессионные ключи каждый раз, а хранить их и начинать новую сессию со старым сессионным ключем.

## Лекция 9. Тунели

**OpenVPN** - работает на TCP и UDP на портах 1194, шифрует трафик с помощью TLS. Предоставляет два вида виртуальных устройств (интерфейсов):
- `tun` (L3) - берет IP-пакет, заменяет его source address IP-адресом `tun`-интерфейса;
- `tap` (L2) - берет не IP-пакет, а целый Ethernet-фрэйм и отдает его на другой конец. С логической точки зрения устройства с разных концов VPN'а соеденены мостом. В такой конфигурации интерфейс `tap` может не иметь IP-адреса. Ему достаточно иметь MAC-адрес.

**WireGuard** - использует только UDP, формально может быть любой порт, не использует TLS, но шифрует трафик иначе, поэтому он гораздо проще в реализации. Реализован в ядре Linux. Работает на уровне L3.

**HTTP proxy** - тип прокси-сервера, который действует как сервер-посредник между клиентом и веб-сервером. При использовании HTTP-прокси происходит следующее: запрос попадает не на сайт, а на прокси-сервер в виде обычного текста. После этого прокси-сервер анализирует его и посылает новый запрос на сайт, используя данные из запроса, но изменяя IP-адрес (возможно). Веб-сайт получает его и отправляет ответ на прокси-сервер, после чего сервер пересылает ответ пользователю.

**Пример**: TCP port 3128
```
GET https://neerc.itmo.ru/teaching/networking/ HTTP/1.1
Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

**Примечание**: Существует также HTTP-proxy-over-TLS.

**SOCS5** - сетевой протокол уровня L4 (TCP/UDP), который позволяет пересылать пакеты от клиента к серверу через прокси-сервер прозрачно (незаметно для них) и таким образом использовать сервисы за межсетевыми экранами (файрволами). Предполагает аутентификацию, так что только авторизованные пользователи получают доступ к серверу. Не использует шифрование и работает по TCP на порту 1080.

**Shadowsocks** - это бесплатный проект протокола шифрования с открытым исходным кодом, который широко используется в Китае для обхода интернет-цензуры. По протоколу SOCS5 происходит подключение к локальному сервис, дальше зашифрованные данные отправляются на удаленный сервис, который уже устанавливает TCP соединение с целевым сервером.

**SSH** (*Secure Shell* - *безопасная оболочка*) — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов). Linux-утилита `ssh` предоставляет следующий функционал:
- Connection to port on local forwarded to host:hostport from remote machine
  - `L [bind_address:]port:host:hostport`
- Connection to port on remote machine forwarded to host:hostport from local machine
  - `-R [bind_address:]port:host:hostport`
- SOCKS5
  - `-D [bind_address:]port`
- L3 (tun)
  - `-w local_tun[:remote_tun]`
- L2 (tap)
  - `-o Tunnel=ethernet`

**IPsec** - набор протоколов для обеспечения защиты данных, передаваемых по межсетевому протоколу IP. Позволяет осуществлять подтверждение подлинности, проверку целостности и/или шифрование IP-пакетов. IPsec также включает в себя протоколы для защищённого обмена ключами в сети Интернет.

При подключении по IPseq происходит обмен ключами, шифрование IP-пакетов на клиенте и дешифрование на сервере.

**Примечание**: IPsec (обычно) не подменяет IP-адреса.

**Примечание**: Похожие технологии - GRE, IP-in-IP, L2TP (PPTP). Все эти протоколы ничего не шифруют, они позволяют отправить IP-пакет не туда, куда вы хотите его отправить (очень удобно). По факту происходит следующее. IP-пакет оборачивается в другой IP-пакет с другим DST и SRC, отправляется, распаковывается и отправляется на исходный DST и с исходным SRC.

**MPLS** (*Multiprotocol Label Switcing* - *многопротокольная коммутация по меткам*) - механизм в высокопроизводительной телекоммуникационной сети, осуществляющий передачу данных от одного узла сети к другому с помощью меток. Позволяет отправить IP-пакет не туда, когда он бы отправился по умолчанию. Между IP-пакетом и Ethernet-хэдером прибавляется MPLS-хэдер, содержащий метки, а маршрутизатор учитывает его содержимое:

![MPLS](./images/MPLS.png "MPLS")

**TOR** (*The Onion Router*):

![TOR](./images/tor.jpg "TOR")

## Лекция 10. Ethernet и WiFi

### Wire encoding

Существует несколько подходов к передаче информации по проводам (нельзя просто кодировать нулями и единицами напряжения, так как если мы передаем 1000 ноликов подряд, то очень тяжело понять, точно ли это было именно 1000 ноликов, а не 999 или 1001):
1. Clock wire - два провода: первый отправляет 0 или 1, по второму передаются скачки напряжения до 1 на каждый такт.
2. Manchester coding - кодирование 1 как перепада напряжения с 1 до 0, а 0, как перепада от 0 к 1 (см. изображение ниже).
3. 8b/10b - подход, который обычно используется в Ethernet - подразумевает кодирование n битами m-битные числа (m < n) так, чтобы в этих числах было достаточно много перепадов напряжения.

![Manchester Encoding](./images/manchester-encoding.png "Manchester Encoding")

Стандарты Ethernet:
- 802.3 10BASE5
- 802.3 10BASE2

Первым проводом, по которому стали передавать Интернет - это коаксиал. К нему подключались компьютеры. В таком варианте можно было транслировать на всех одну и ту же информацию, а те, кому она не предназначалась - просто её выкидывали. Сложность возникает в тот момент, когда кто-то хочет передавать данные одновременно. Существуют следующие подходы к решению этой проблемы:
1. **Carrier sense multiple access with collision detection (CSMA/CD)** - подход при котором если кто-то хочет передавать и провод свободен, то он передает, если провод занят, то не передает. В случае коллиций нужно подождать некоторое случайное время. Если снова произойдет коллизия, то подождать чуть подольше и т. д.
2. Token ring - передача токена по очереди между всеми желающими пользоваться интернетом.

Далее придумали витую пару (в одном проводе 4 пары переплетенных проводов). Её стандарты (8P8C, RJ45):
- 10BASE-T
- 100BASE-T
- 1000BASE-T
- 2.5GBASE-T
- 10GBASE-T
- 40GBASE-T

**Примечание**: 10BASE-T и 100BASE-T.

Стандарты витой пары:

![ANSI/TIA-568](./images/ansi-tia-568.jpg "ANSI/TIA-568")

С помощью витой пары можно соединить два компьютера. Можно соединить пару третьего с парами двух других и тогда получится соединить три компьютера. Такая система называется хабом (*hub*). По стандарту хаб не может передавать данные со скоростью выше 10 МБит.

Передавать электричество к роутеру можно прямо по витой паре. Такая технология называется **Power over Ethernet** (*PoE*). Ее принцип состоит в том, что измеряется сопротивление между двумя проводниками, затем подается сигнал на витую пару и если его сопротивление изменилось правильным образом - подается напряжение на пару кабеля.

Третье, по чему работает Ethernet, - **оптическое волокно** (*optical fiber*). Модификации:
- Mutli-mode
- Single-mode

Оптоволокно используется, когда что-то хочется передавать быстро и далеко.

**WDM** (*Wavelength Division Multiplexing* - *мультиплексирование с разделением по длине волны*) — принцип разделения спектрального ресурса оптического волокна между длинами световых волн с последующим мультиплексированием, позволяющий одновременно пнегоередавать несколько информационных каналов по одному оптическому волокну на разных несущих частотах:

![WDM](./images/wdm.webp "WDM")

**DWDM** (*Dense Wavelength Division Multiplexing*) — плотное мультиплексирование с разделением по длине волны. Расстояние между несущими в DWDM-системах может составлять 25 — 200 ГГц, в современных сетях наиболее часто используется сетка каналов с шагом 50 ГГц .

**Примечание**: Можно разделять не только по длине волны, но и по полярности.

Оптоволокно, которое соединяет континенты (*submarine cable*):

![Submarine Cable](./images/submarine-cable.jpg "Submarine Cable")

### Tagged VLAN

**VLAN** (*Virtual Local Area Network*) — виртуальная локальная компьютерная сеть. Представляет собой группу хостов с общим набором требований, которые взаимодействуют так, как если бы они были подключены к широковещательному домену независимо от их физического местонахождения. VLAN имеет те же свойства, что и физическая локальная сеть, но позволяет конечным членам группироваться вместе, даже если они не находятся в одной физической сети.

**IEEE 802.1Q** — открытый стандарт, который описывает процедуру тегирования трафика для передачи информации о принадлежности к VLAN по сетям стандарта IEEE 802.3 Ethernet. Таким образом, можно разделить одну физическую сеть на две VLAN.

**Пример**: Заголовок с тегом:

![802.1q](./images/802.1q.png, "802.1q")

### Wake-on-LAN

**Wake-on-LAN** — технология, позволяющая удалённо включить компьютер посредством отправки через локальную сеть специальной последовательности байтов — пакета данных. Этот пакет может быть вставлен в пакеты любых стандартных протоколов более высоких уровней, например, UDP или IPX. Пакет выглядит как `ff:ff:ff:ff:ff:ff + <mac-address> * 16`.

### STP

**STP** (*spanning tree protocol*) - протокол, согласно которому строится остовное дерево в Ethernet-сетях (позволяет бороться с циклами, к которых речь уже шла во вводной лекции).

### Wi-Fi

Wi-Fi работает по стандарту IEEE 802.11 и имеет следующие версии:
- 802.11b
- 802.11g
- 802.11n
- 802.11ac
- 802.11ax

Wi-Fi работает на одном из 14 каналов 2G (14 доступен только в Японии). Wi-Fi Работает на каком-то канале. Когда происходят коллизии - работаем по алгоритму CSMA/CD.

**Примечание**: Есть также диапазон 5G, там больше каналов, но не все они доступны (в разных странах разные каналы заняты).

**DFS** (*dynamic frequency selection*) - алгоритм при котором Wi-Fi-точка следит за определенным каналом 5G некоторое время и если он не получает никаких сообщений с, например, метеорадаров, то запускается на этой частоте. В противном случае она пробует следить за другой частотой.

**BSS** (*basic service set*) - режим работы Wi-Fi, при котором все узлы взаимодействуют между собой через одну AP, которая может играть роль моста для подключения к внешней кабельной сети.

Wi-Fi имеет два параметра - BSSID (MAC) и SSID (название). Если устройство подключено к Wi-Fi с каким-то SSID, то можно подойти к нему и включить другую Wi-Fi-точку помощнее, с таким же SSID - устройство переподключится к нему - можно будет отследить трафик. Но использовать это можно в благих целях:

![ESS](./images/extended-service-set.svg "ESS")

**ESS** (*extended service set*) - режим, позволяющий объединить несколько точек доступа, т.е. объединяет несколько сетей BSS. В данном случае точки доступа могут взаимодействовать и друг с другом. Расширенный режим удобно применять тогда, когда необходимо объединить в одну сеть несколько пользователей или подключить несколько проводных или беспроводных сетей.

**Пример**: В большом ИТМО везде работает WiFi "IMTO Guests".

## Лекция 11. Маршрутизация

Чтобы посмотреть таблицу маршрутизации в Linux, можно использовать следующую команду:
```
igor@acer:~$ ip route
default via 192.168.0.1 dev wlp9s0 proto dhcp metric 600
10.113.207.0/24 dev mpqemubr0 proto kernel scope link src 10.113.207.1
169.254.0.0/16 dev mpqemubr0 scope link metric 1000
192.168.0.0/24 dev wlp9s0 proto kernel scope link src 192.168.0.104 metric 600
```

**Подходы к построению таблицы маршрутизации**:
1. **Статическая маршрутизация** (*static routing*) - вид маршрутизации, при котором маршруты указываются в явном виде при конфигурации маршрутизатора. Вся маршрутизация при этом происходит без участия каких-либо протоколов маршрутизации.
2. **Протоколы маршрутизации на основе состояния канала** (*link state routing protocols*) - это один из двух основных классов протоколов маршрутизации, используемых в сетях с коммутацией пакетов для компьютерной связи. Примеры протоколов маршрутизации на основе состояния канала включают в себя Open Shortest Path First (OSPF) и Intermediate System to Intermediate System (IS-IS). Основная концепция маршрутизации на основе состояния канала заключается в том, что каждый узел строит карту подключения к сети в виде графа. Затем каждый узел независимо вычисляет следующий наилучший логический путь от него до всех возможных пунктов назначения в сети.
3. Протоколы дистанционно-векторной маршрутизации (*distance vector routing protocols*) - второй класс протоколов маршрутизации. Такие протоколы (например, RIP) определяют наилучший маршрут для пакетов данных в зависимости от расстояния.
4. Software-defined networks

Для домашнего компьютера в модели, когда Интернет - это "облако сверху" - этого достаточно. Для сложных сетей в датацентрах настраивать сеть руками очень сложно, поэтому существуют специальные алгоритмы, которые строят таблицу маршрутизации.

**RIP** (*routing information protocol*) - алгоритм Беллмана-Форда - один из самых простых протоколов маршрутизации. Применяется в небольших компьютерных сетях, позволяет маршрутизаторам динамически обновлять маршрутную информацию (направление и дальность в хопах), получая ее от соседних маршрутизаторов. Запись в таблице маршрутизации состоит из трех параметров: destination-узла маршрута, расстояния до него и указателя на следующий узел в маршруте. Например, `10.1.0.0/16 4 nexthop: 10.4.0.1`.

Максимальное количество транзитных участков (роутеров на пути), разрешенное в RIP — 15 (метрика 16 означает «бесконечно большую метрику»). Каждый RIP-маршрутизатор по умолчанию вещает в сеть свою полную таблицу маршрутизации раз в 30 секунд, довольно сильно нагружая низкоскоростные линии связи. RIP работает в сетях TCP/IP, используя UDP порт 520.

Коротко об алгоритме. Алгоритм Беллмана-Форда - это алгоритм поиска кратчайшего пути во взвешенном графе. Для графа с n вершинами и m ребрами он работает за O(nm). Алгоритм решает задачу методом динамического программирования, строя матрицу `A`, в которой `A[v][k]` - это длина кратчайшего пути из `s` в `v`, содержащий не более `k` ребер. Так изначально все значения, кроме `A[s][0]` равны бесконечности, а дальше релаксируются расстояния и маршруты для путей длины 1, затем для путей длины 2 и т. д.

При разрыве какого-нибудь соединения таблицу маршрутизации можно перестроить.

**Примечание**: В современных сетевых средах RIP — не самое лучшее решение для выбора в качестве протокола маршрутизации, так как его возможности уступают более современным протоколам. Ограничение на 15 транзитных участков не дает применять его в больших сетях. Преимущество этого протокола — простота конфигурирования.

**Routing loops** (*петли маршрутизации*) — это маршруты в сети передачи данных, приводящие на один и тот же маршрутизатор более одного раза. Могут возникать, когда по алгоритму RIP перестраивается таблица маршрутизации после разрыва одного из соединений (нампример, может проявляться как циклическое обновление соседних узлов). Для RIP это не приводит к зависанию навсегла, так как в какой-то момент маршруты дорастут до лимита 16 и все поймут, что destination-узел не достижим, но сам этот процесс очень долгий, поэтому лучше с ним бороться.

**Расширения RIP**:
1. Split horizon - метод предотвращения петель маршрутизации, вызванных медленной сходимостью дистанционно-векторных протоколов маршрутизации. Правило расщеплённого горизонта говорит, что маршрутизатор не должен распространять информацию о сети через интерфейс, на который прибыло обновление;
2. Route poisoning - если маршрут становится недоступен, роутер ставит маршруту метрику 16 и сообщает всем что у данного маршрута метрика 16, т.е. не достижим.

Данные расширения позволяют бороться с возникновением петель.

**OSPF** (*Open Shortest Path First*) - протокол динамической маршрутизации, работающий поверх IPv4 или IPv6 и основанный на технологии отслеживания состояния канала (link-state technology) и использующий для нахождения кратчайшего пути алгоритм Дейкстры. Алгоритм состоит из следующих шагов:
1. При включении роутера, он получает ID;
2. Затем он шлет hello-пакеты по всем интерфейсам;
3. С соседями, которые ему ответили он устанавливает "соседские отношения", обменивается метаинформацией;
4. Затем роутер по multicast'у сообщает всем информацию о своих соседях и сетях, к которым он подключен;
5. Поскольку все имеют полное представление о графе сети, при построении маршрута можно использовать алгоритм Дейскстры для построения кратчайшего пути от source-узла до destination-узла.

**Примечание**: Использовать OSPF в Интернете не получится, так как там слишком много узлов (и потому что далеко не все хотят рассказывать устройство своей сети), но можно использовать в рамках одной локальной сети в компании.

**Примечание**: Может быть эффективнее разделение всей сети на зоны и запуск OSPF в рамках каждой из зон.

**IS-IS** (*Intermediate System to Intermediate System* - *протокол маршрутизации промежуточных систем*) - протокол, стандартизированный ISO и использующийся в основном в крупных сетях провайдеров услуг. Может также использоваться в корпоративных сетях особо крупного масштаба. Он обеспечивает быструю сходимость и отличную масштабируемость. Как и все протоколы на основе состояния каналов, IS-IS очень экономно использует пропускную способность сетей.

**Автономная система** (*autonomous system*, *AS*) в Интернете — система IP-сетей и маршрутизаторов, управляемых одним или несколькими операторами, имеющими единую политику маршрутизации с Интернетом. Каждая автономная система имеет свой номер ASN (присваивает IANA, является 16- или 32-битным числом - вторые появились, когда первые закончились) и фактически принадлежит определенной компании. Например, Google или Telia.

Утилита `whois` позволяет по номеру AS понять, кому она принадлежит:
```
igor@acer:~$ whois AS15169 | grep AS
ASNumber:       15169
ASName:         GOOGLE
ASHandle:       AS15169
igor@acer:~$ whois AS3249 | grep AS
% Information related to 'AS3209 - AS3353'
as-block:       AS3209 - AS3353
descr:          RIPE NCC ASN block
remarks:        These AS Numbers are assigned to network operators in the RIPE NCC service region.
% Information related to 'AS3249'
% Abuse contact for 'AS3249' is 'abuse@telia.ee'
aut-num:        AS3249
status:         ASSIGNED
org-name:       Telia Eesti AS
address:        Telia Eesti AS
```

**BGP4** (*Border Gateway Protocol*) - протокол динамической маршрутизации, являющийся на текущий момент основным протоколом динамической маршрутизации в сети Интернет. Работает поверх TCP на порту 179.

Маршрутизаторы, использующие протокол BGP, обмениваются информацией о доступности сетей. Вместе с информацией о сетях передаются различные атрибуты этих сетей, с помощью которых BGP выбирает лучший маршрут и настраиваются политики маршрутизации.

Один из основных атрибутов, который передается с информацией о маршруте — это *список автономных систем* (`AS_PATH`), через которые прошла эта информация. Эта информация позволяет BGP определять где находится сеть относительно автономных систем, исключать петли маршрутизации, а также может быть использована при настройке политик.

**Пример работы BGP**:

![BGP](./images/bgp-example.png "BGP")

В данном примере изначально в системе было три компании:

| Автономная сеть | `AS_PATH` |
| :-------------: | :-------: |
|    Company 1    |     -     |
|    Company 2    |     -     |
|    Company 3    |     1     |

При подключении в сеть Сompany 4, она получит от соседей два способа, как можно проложить маршрут до сети `1.2.3.0/24`: 2 от Company 2, 1 3 от Company 3. Для простоты пусть она выбирает самый короткий `AS_PATH`. Далее она уведомляет своих соседей, что они могут отправлять пакеты по пути 2 4. Company 2 этот маршрут не интересен, так как у неё уже есть более короткий (к тому же она уже присутствует в предлагаемом маршруте, а это явно не оптимально). Company 3 сравнит маршрут со своим - 1 короче, чем 2 4, поэтому она также ну будет обновлять свой маршрут. В итоге получаем новую таблицу:

| Автономная сеть | `AS_PATH` |
| :-------------: | :-------: |
|    Company 1    |     -     |
|    Company 2    |     -     |
|    Company 3    |     1     |
|    Company 4    |     2     |

**Примечание**: Вместе с `AS_PATH` узлы могут передавать соседям метадату: `COMMUNITIES`, которая выглядит как список пар из двух чисел.

**Примечание**: Существует два подвида BGP - eBGP прокладывает маршрут между AS, а iBGP работает в рамках AS.

**Looking Glass** — это серверы в Интернете, на которых запущена одна из множества общедоступных реализаций программного обеспечения Looking Glass. Они обычно развертываются автономными системами, чтобы предложить доступ к своей инфраструктуре маршрутизации, чтобы облегчить отладку сетевых проблем (см. [bgp.he.net](https://bgp.he.net)).

Заметим, что протокол BGP работает на доверии. Если, например, Ростелеком скажет, что он имеет доступ к 8.8.8.8/32, то все запомнят, что по этому адресу надо ходить к нему и будут отправлять пакеты к нему, а он будет делать с ними что хочет. Костыли для решения этой проблемы:
1. Максимальный размер маски подсети - 24;
2. Существует JSON, где можно указать, что для какой-то сети могут иметь доступ только определенные AS;
3. Можно отключать того, кто занимается такими делами.

Хорошее решение - сделать что-то из разряда BGPSEC (вспоминаем DNSSEC). Какие-то черновики уже есть, но это очень сложно для реализации, поэтому фактически решение не актуально (даже DNSSEC до сих пор распространился относительно слабо).

Вторая проблема, которая может произойти с BGP, - это когда кто-то случайно перестает анонсировать свои префиксы. Примерно это произошло с Facebook в 2021 году, когда потерялся путь к их DNS-серверам.

**Порядок выбора лучшего пути**:
1. Предпочитительно наибольшее значение local-preference;
2. Предпочтителен кратчайший `AS_PATH`;
3. Предпочтителено наименьшее значение origin;
4. Предпочтителено наименьшее значение MED;
5. Предпочтительны маршруты полученные из eBGP (а не из iBGP);
6. Предпочтителен наилучший выход из AS;
7. Для маршрутов, полученных с помощью EBGP, предпочтителен текущий активный маршрут;
8. Предпочтительны маршруты от однорангового узла с наименьшим идентификатором маршрутизатора;
9. Предпочтительны маршруты с наименьшей длиной кластера;
10. Предпочтительны маршруты от однорангового узла с наименьшим IP-адресом.

Еще немного о структуре интернета. Если маленький провайдер хочет подключиться к интернету, то он обычно обращается к более крупному провайдеру, тот к еще более крупному и т. д. по цепочке. Обычно выгодно создавать пилинговое соединение между двумя компаниями. Это можно делать напрямую, либо через публичные точки обмена. Условия для установления прямых пилинговых соединений компании должны договориться и протянуть провод.

Карта Интернета (отношения между интернет-провайдерами):
![Relationship between the various tiers of Internet providers](./images/tier-1-providers-map.png "Relationship between the various tiers of Internet providers
")
